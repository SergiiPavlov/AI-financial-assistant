# Voice Finance Agent (starter)

Голосовой личный бухгалтер поверх mini-CRM.

## Что это

Стартовый каркас backend-сервиса, который:

- поднимает Express-сервер на TypeScript;
- использует Prisma для доступа к БД;
- содержит модель `FinanceTransaction` для учёта личных расходов;
- имеет базовые маршруты:
  - `GET /api/health` — проверка работоспособности;
  - `GET /api/finance/transactions` — заглушка для списка транзакций;
  - `GET /api/finance/summary` — заглушка для сводки расходов.

Дальше сюда будут добавлены:

- `POST /api/finance/transactions` — создание транзакций;
- `POST /api/finance/parse-text` — парсер текстовых фраз в транзакции (LLM);
- `POST /api/finance/voice` — голосовой ввод через Whisper;
- `POST /api/finance/assistant` — диалоговый ИИ-бухгалтер.

## Быстрый старт

1. Установить зависимости:

   ```bash
   npm ci
   ```

2. Создать `.env` на основе `.env.example` и прописать:

   - `DATABASE_URL`
   - `AUTH_JWT_SECRET` и `AUTH_REFRESH_SECRET` (рандомные строки 32+ байт)
   - `OPENAI_API_KEY` (позже, когда будем подключать LLM)
   - `PORT` (по умолчанию 4001)

3. Сгенерировать Prisma Client и прогнать первую миграцию:

   ```bash
   npm run prisma:generate
   npm run prisma:migrate
   ```

4. Запустить dev-сервер:

   ```bash
   npm run dev
   ```

### Переменные окружения

Минимальный набор для работы сервера:

- `DATABASE_URL` — строка подключения к PostgreSQL;
- `AUTH_JWT_SECRET` — секрет для подписи access-токенов (HS256, 32+ байт);
- `AUTH_REFRESH_SECRET` — секрет для refresh-токенов (HS256, 32+ байт);
- `PORT` — порт HTTP-сервера (по умолчанию `4001`).

Рекомендуемые настройки:

- `CORS_ORIGIN` — домен фронтенда, если он на другом origin;
- `COOKIE_SECURE` — `true` в production, `false` в dev для http;
- `ALLOW_BODY_USERID` — временный флаг для ручных запросов без JWT.

Сгенерировать секреты удобно так:

```bash
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
```

Проверка на чистой машине (после настройки `.env`):

```bash
npm ci
npm run prisma:generate
npm run prisma:migrate
npm run build
npm start
```

После этого будет доступен:

- `GET http://localhost:4001/api/health`
- `GET http://localhost:4001/api/finance/transactions`
- `GET http://localhost:4001/api/finance/summary`

## Voice Finance — отдельный продукт «Голосовой бухгалтер»

Voice Finance — это независимый сервис «голосового личного бухгалтера».
Он принимает текстовые (и в будущем голосовые) фразы о расходах, сохраняет их в базу и даёт аналитику по дням, месяцам и категориям.

### Быстрый старт (локально)

1. Установить зависимости:

   ```bash
   npm ci
   ```

2. Настроить окружение в `.env` (см. `.env.example`):

- `DATABASE_URL` — строка подключения к Postgres;
- `AUTH_JWT_SECRET` — секрет для подписи access-токенов (32+ байт);
- `AUTH_REFRESH_SECRET` — секрет для refresh-токенов (32+ байт);
- `PORT` — порт HTTP-сервера (по умолчанию `4001`);
- `CORS_ORIGIN` / `COOKIE_SECURE` — по ситуации (фронт на другом origin / https);
- `ALLOW_BODY_USERID` — включать только для ручного тестирования без JWT;
- `OPENAI_API_KEY` и `AI_FINANCE_MODEL` — опционально, понадобятся при подключении LLM.

3. Прогнать миграции Prisma:

   ```bash
   npm run prisma:generate
   npm run prisma:migrate
   ```

4. Собрать и запустить:

   ```bash
   npm run build
   npm start
   ```

5. Открыть демо-страницу:

   ```text
   http://localhost:4001/demo.html
   ```

   Поток работы:

   - Нажать **«Получить demo-токен»** — сервис выдаст JWT для `demo_user`.
   - Ввести фразу о расходах (например: `Сегодня 300 на продукты и 200 на такси`).
   - Нажать **«Отправить /parse-text»** — увидеть, как LLM разобрал фразу в список транзакций.
   - Нажать **«Сохранить транзакции»** — данные попадут в БД.
   - Нажать **«Загрузить /transactions»** — посмотреть сырые записи.
   - Настроить период и нажать **«Получить summary»** — увидеть сводку по сумме, категориям и датам.
   - В блоке **«Вопрос ассистенту»** задать вопрос (например: `Сколько потратил на еду в этом месяце?`) — ассистент ответит на основе реальных данных пользователя.

### Клиенты

Сервис задуман как ядро, к которому можно подключать разные клиенты:

- веб-приложение (UI вместо demo.html),
- мобильное приложение (Android/iOS),
- интеграции с другими системами.

Все клиенты общаются с сервисом через HTTP API и JWT.

## Интеграция с внешней CRM (опционально, в будущем)

Сервис Voice Finance спроектирован как независимый модуль учёта расходов, который можно подключать к другим системам через API.

### Модель пользователя

Все операции привязаны к строковому `userId`:

- в БД (`FinanceTransaction.userId`) это внешний идентификатор пользователя,
- в JWT `userId` ожидается в полях `id` и/или `sub`,
- вся аналитика (`/api/finance/summary`, `/api/finance/assistant`) строится по этому идентификатору.

Внешняя CRM может использовать тот же `userId`, что и в своём хранилище пользователей.

### Вариант 1: CRM как клиент API

Сценарий:

- Пользователь логинится в CRM.
- CRM знает его `userId` и формирует JWT с payload:

  ```json
  {
    "sub": "<userId>",
    "id": "<userId>",
    "email": "user@example.com"
  }
  ```

- CRM-фронтенд или CRM-бэкенд обращается к Voice Finance:

  ```http
  GET /api/finance/summary?from=2025-01-01&to=2025-01-31
  Authorization: Bearer <jwt от CRM>
  ```

- Сервис возвращает сводку расходов по этому пользователю.
- В интерфейсе CRM можно добавить кнопку:

  > «Использовать данные из Голосового бухгалтера»

  и показывать там категории/суммы из Voice Finance.

### Вариант 2: CRM как агрегатор

- CRM периодически забирает агрегированные данные:
  - по пользователю,
  - по проекту,
  - по периоду;
- сохраняет их у себя как «финансовые показатели» по кейсам/проектам.

В этом сценарии можно использовать отдельный service-JWT, который даёт CRM доступ только на чтение к нужным маршрутам.

### Требования к JWT

Сервис ожидает:

- алгоритм: `HS256`,
- секрет: `AUTH_JWT_SECRET` (из переменных окружения),
- поля в payload:
  - `id` и/или `sub` — идентификатор пользователя,
  - `email` (опционально, для логов).

Если `req.user.id` есть, он используется как основной `userId`.
Если токена нет, временно поддерживается `userId` в теле запроса (fallback для ручных тестов), но это считается устаревающим поведением.


## Как пользоваться как отдельным продуктом (Voice Finance как мини‑приложение)

1. Запусти сервер локально (см. раздел «Quick start») и открой `http://localhost:4001/demo`.
2. Нажми «Получить demo‑токен» — вверху появится сообщение, что токен получен для `demo_user`.
3. В блоке «Парсинг текста»:
   - введи `userId` (например, `demo_user`),
   - введи фразу вида «Сегодня 300 грн на продукты и 200 на такси»,
   - нажми «Отправить /parse-text`,
   - проверь распознанные транзакции, предупреждения и вопросы,
   - при необходимости — нажми «Сохранить транзакции».
4. В блоке «Транзакции» нажми «Загрузить /transactions», чтобы увидеть историю.
5. В блоке «Сводка» задай период и нажми «Получить summary», чтобы увидеть суммы по категориям и датам.
6. В блоке «Вопрос ассистенту» напиши вопрос вроде «Сколько потратил на еду в этом месяце?» и нажми «Спросить».

Интерфейс демо‑страницы поддерживает три языка (RU / UK / EN) только для подписей и подсказок — сами данные (категории, описания, вопросы) могут быть любыми.

## Как интегрировать с mini‑CRM в будущем (набросок)

- Voice Finance уже работает по JWT‑аутентификации, где `userId` берётся из `id`/`sub` в токене.
- mini‑CRM может выдавать собственный JWT с тем же `userId`, который она использует в своей БД.
- Через этот JWT CRM может:
  - вызывать `/api/finance/transactions` и `/api/finance/summary` для отображения расходов,
  - вызывать `/api/finance/assistant` для ответов ассистента прямо внутри CRM‑интерфейса.
- На уровне UI CRM достаточно добавить кнопку вроде «Подтянуть данные из Голосового Бухгалтера» — она будет дергать нужные API Voice Finance от имени текущего пользователя.

Подробная схема интеграции описана выше в разделе про JWT и варианты использования.

